"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateSchema = exports.diffSchema = void 0;
const clc = require("colorette");
const sql_formatter_1 = require("sql-formatter");
const types_1 = require("./types");
const client_1 = require("./client");
const connect_1 = require("../gcp/cloudsql/connect");
const prompt_1 = require("../prompt");
const logger_1 = require("../logger");
const error_1 = require("../error");
const projectUtils_1 = require("../projectUtils");
const utils_1 = require("../utils");
const IMCOMPATIBLE_SCHEMA_ERROR_TYPESTRING = "type.googleapis.com/google.firebase.dataconnect.v1main.IncompatibleSqlSchemaError";
async function diffSchema(schema) {
    var _a, _b;
    const dbName = (_a = schema.primaryDatasource.postgresql) === null || _a === void 0 ? void 0 : _a.database;
    const instanceName = (_b = schema.primaryDatasource.postgresql) === null || _b === void 0 ? void 0 : _b.cloudSql.instance;
    if (!instanceName || !dbName) {
        throw new error_1.FirebaseError(`tried to diff schema but ${instanceName} was undefined`);
    }
    try {
        const serviceName = schema.name.replace(`/schemas/${types_1.SCHEMA_ID}`, "");
        await ensureServiceIsConnectedToCloudSql(serviceName);
        await (0, client_1.upsertSchema)(schema, true);
    }
    catch (err) {
        const incompatible = getIncompatibleSchemaError(err);
        if (incompatible) {
            displaySchemaChanges(incompatible);
            return incompatible.diffs;
        }
        throw err;
    }
    logger_1.logger.debug(`Schema was up to date for ${instanceName}:${dbName}`);
    return [];
}
exports.diffSchema = diffSchema;
async function migrateSchema(args) {
    var _a, _b;
    const { schema, validateOnly } = args;
    const databaseId = (_a = schema.primaryDatasource.postgresql) === null || _a === void 0 ? void 0 : _a.database;
    if (!databaseId) {
        throw new error_1.FirebaseError("Schema is missing primaryDatasource.postgresql?.database, cannot migrate");
    }
    const instanceId = (_b = schema.primaryDatasource.postgresql) === null || _b === void 0 ? void 0 : _b.cloudSql.instance.split("/").pop();
    if (!instanceId) {
        throw new error_1.FirebaseError(`tried to migrate schema but ${instanceId} was undefined`);
    }
    try {
        const serviceName = schema.name.replace(`/schemas/${types_1.SCHEMA_ID}`, "");
        await ensureServiceIsConnectedToCloudSql(serviceName);
        await (0, client_1.upsertSchema)(schema, validateOnly);
        logger_1.logger.debug(`Database schema was up to date for ${instanceId}:${databaseId}`);
        return [];
    }
    catch (err) {
        const incompatible = getIncompatibleSchemaError(err);
        if (!incompatible) {
            throw err;
        }
        const diffs = await handleIncompatibleSchemaError(Object.assign(Object.assign({}, args), { incompatibleSchemaError: incompatible, instanceId,
            databaseId }));
        await (0, client_1.upsertSchema)(schema, validateOnly);
        return diffs;
    }
}
exports.migrateSchema = migrateSchema;
async function handleIncompatibleSchemaError(args) {
    const { incompatibleSchemaError, options, instanceId, databaseId, allowNonInteractiveMigration } = args;
    const projectId = (0, projectUtils_1.needProjectId)(options);
    const iamUser = await (0, connect_1.setupIAMUser)(instanceId, databaseId, options);
    const choice = await promptForSchemaMigration(options, databaseId, incompatibleSchemaError, allowNonInteractiveMigration);
    const commandsToExecute = incompatibleSchemaError.diffs
        .filter((d) => {
        switch (choice) {
            case "all":
                return true;
            case "safe":
                return !d.destructive;
            case "none":
                return false;
        }
    })
        .map((d) => d.sql);
    if (commandsToExecute.length) {
        await (0, connect_1.execute)([
            `SET ROLE "${(0, connect_1.firebaseowner)(databaseId)}"`,
            ...commandsToExecute,
            `GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA "public" TO PUBLIC`,
        ], {
            projectId,
            instanceId,
            databaseId,
            username: iamUser,
        });
        return incompatibleSchemaError.diffs;
    }
    return [];
}
async function promptForSchemaMigration(options, databaseName, err, allowNonInteractiveMigration) {
    displaySchemaChanges(err);
    if (!options.nonInteractive) {
        const choices = err.destructive
            ? [
                { name: "Execute all changes (including destructive changes)", value: "all" },
                { name: "Execute only safe changes", value: "safe" },
                { name: "Abort changes", value: "none" },
            ]
            : [
                { name: "Execute changes", value: "safe" },
                { name: "Abort changes", value: "none" },
            ];
        return await (0, prompt_1.promptOnce)({
            message: `Would you like to execute these changes against ${databaseName}?`,
            type: "list",
            choices,
        });
    }
    else if (!allowNonInteractiveMigration) {
        logger_1.logger.error("Your database schema is incompatible with your Data Connect schema. Run `firebase dataconnect:sql:migrate` to migrate your database schema");
        return "none";
    }
    else if (options.force) {
        return "all";
    }
    else if (!err.destructive) {
        return "safe";
    }
    else {
        logger_1.logger.error("This schema migration includes potentially destructive changes. If you'd like to execute it anyway, rerun this command with --force");
        return "none";
    }
}
async function ensureServiceIsConnectedToCloudSql(serviceName) {
    let currentSchema;
    try {
        currentSchema = await (0, client_1.getSchema)(serviceName);
    }
    catch (err) {
        if (err.status === 404) {
            return;
        }
        throw err;
    }
    if (!currentSchema.primaryDatasource.postgresql ||
        currentSchema.primaryDatasource.postgresql.schemaValidation === "STRICT") {
        return;
    }
    currentSchema.primaryDatasource.postgresql.schemaValidation = "STRICT";
    await (0, client_1.upsertSchema)(currentSchema, false);
}
function displaySchemaChanges(error) {
    const message = "Your new schema is incompatible with the schema of your CloudSQL database. " +
        "The following SQL statements will migrate your database schema to match your new Data Connect schema.\n" +
        error.diffs.map(toString).join("\n");
    (0, utils_1.logLabeledWarning)("dataconnect", message);
}
function toString(diff) {
    return `\/** ${diff.destructive ? clc.red("Destructive: ") : ""}${diff.description}*\/\n${(0, sql_formatter_1.format)(diff.sql, { language: "postgresql" })}`;
}
function getIncompatibleSchemaError(err) {
    var _a;
    const original = ((_a = err.context) === null || _a === void 0 ? void 0 : _a.body.error) || err.orignal;
    if (!original) {
        throw err;
    }
    const details = original.details;
    const incompatibles = details.filter((d) => d["@type"] === IMCOMPATIBLE_SCHEMA_ERROR_TYPESTRING);
    return incompatibles[0];
}
